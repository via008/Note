## 最优子结构

如果一个问题的最优解包含其子问题的最优解，就称此问题具有**最优子结构**性质。

在发掘最优子结构性质的过程中，实际上遵循了如下的通用模式：

1. 证明问题最优解的第一个组成部分是做出一个选择，做出这个选择会产生一个或多个待解的子问题。
2. 对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。你并不关心这种选择是如何得到的，只是假定已经知道了这种选择。
3. 给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地*刻画子问题空间*。
4. 作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。

一个刻画子问题空间的好经验是：保持子问题空间尽可能简单，只在必要时才扩展它。

对于不同问题领域，最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题，以及
2. 在确定最优解使用哪些子问题时，我们需要考察多少种选择。

在动态规划方法中，我们通常**自底向上**地使用最优子结构。也就是说首先求得子问题的最优解，然后求出原问题的最优解。在求解原问题的过程中，我们需要在涉及的子问题中做出选择，选出能得到原问题最优解的子问题。原问题最优解的代价通常就是子问题最优解的代价再加上**此次选择**直接产生的代价。

## 重叠子问题

适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够“小”，即问题的递归算法会**反复的求解相同的子问题**，而不是一直生成新的子问题。

一般来讲，不同子问题的总数是输入规模的多项式函数为好。

如果递归算法反复求解相同的子问题，我们就称最优化问题具有**重叠子问题**性质。

动态规划算法通常这样利用重叠子问题的性质：对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为**常量时间**。

## 重构最优解

我们通常将每个子问题所做的选择存入一个表中，这样就不必根据代价值来重构这些信息。

## 备忘

动态规划算法中，我们可以保持自顶向下策略，同时达到与自底向上动态规划方法相似的效率。思路就是对自然但低效的递归算法加入**备忘**机制。与自底向上方法一样，我们维护一个表记录子问题的解，但仍保持递归算法的控制流程。

带备忘的递归算法为每个子问题维护一个表项来保存它的解。当递归调用过程中第一次遇到子问题时，计算其解，并存入对应表项。随后每次遇到同一个子问题，只是简单的查表，返回其值。
