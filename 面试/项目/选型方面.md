# 为什么要使用微前端？
（对比微前端和别的实现方式的优势）

- 需求分析：多项目/跨团队协作 + 模块复用 + 可独立部署
- 成熟方案：微前端、iframe、UMD/ESM 模块、Module Federation、组件库

微前端的优势：
- 解决多人/多团队并行开发的复杂性
- 技术栈隔离与渐进式重构：现实中很多大规模前端项目存在技术债问题
- 独立部署，稳定性高，恢复能力强


（主要从 “复用粒度”、“部署模式”、“团队协作边界” 不同，分析哪种方案更加适合我们：

复用粒度：
- 微前端：复用粒度属于应用级别，隔离性中等，通信复杂度低
- iframe：复用粒度应用级，隔离和通信复杂度都比较高
- UMD/ESM 模块：复用粒度模块级别，隔离性和通信复杂度都比较低
- Module Federation：复用粒度也在模块级别，隔离性低，通信复杂度也比较低
- 组件库：复用粒度组件级，隔离和通信复杂度都很低

我们的项目需要做到应用级别的复用，并且需要一定程度的强隔离、较完善的通信方式，所以现在有两种方式，一种就是微前端，还有就是 iframe，没有选择 iframe 主要还是因为它实在太慢了。 

| 方案                | 粒度  | 隔离性  | 通信复杂度 | 推荐场景               |
| ----------------- | --- | ---- | ----- | ------------------ |
| 微前端      | 应用级 | 中等   | 中等    | 多团队、独立部署           |
| iframe            | 应用级 | 高    | 高     | 安全隔离、黑盒集成          |
| UMD/ESM 模块        | 模块级 | 低\~中 | 中     | 轻量模块复用             |
| Module Federation | 模块级 | 中等   | 中等    | 多项目共建，webpack-only |
| 组件库               | 组件级 | 低    | 低     | UI 组件 / 通用逻辑       |）


# 为什么使用 bpmnjs

- bpmnjs
- LogicFlow（滴滴内部开源）
- ReactFlow
- 


# codemirror + Lezer 选型
