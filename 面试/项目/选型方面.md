# 为什么要使用微前端？
（对比微前端和别的实现方式的优势）

- 需求分析：多项目/跨团队协作 + 模块复用 + 可独立部署
- 成熟方案：微前端、iframe、UMD/ESM 模块、Module Federation、组件库

微前端的优势：
- 解决多人/多团队并行开发的复杂性
- 技术栈隔离与渐进式重构：现实中很多大规模前端项目存在技术债问题
- 独立部署，稳定性高，恢复能力强


（主要从 “复用粒度”、“部署模式”、“团队协作边界” 不同，分析哪种方案更加适合我们：

复用粒度：
- 微前端：复用粒度属于应用级别，隔离性中等，通信复杂度低
- iframe：复用粒度应用级，隔离和通信复杂度都比较高
- UMD/ESM 模块：复用粒度模块级别，隔离性和通信复杂度都比较低
- Module Federation：复用粒度也在模块级别，隔离性低，通信复杂度也比较低
- 组件库：复用粒度组件级，隔离和通信复杂度都很低

我们的项目需要做到应用级别的复用，并且需要一定程度的强隔离、较完善的通信方式，所以现在有两种方式，一种就是微前端，还有就是 iframe，没有选择 iframe 主要还是因为它实在太慢了。 

| 方案                | 粒度  | 隔离性  | 通信复杂度 | 推荐场景               |
| ----------------- | --- | ---- | ----- | ------------------ |
| 微前端      | 应用级 | 中等   | 中等    | 多团队、独立部署           |
| iframe            | 应用级 | 高    | 高     | 安全隔离、黑盒集成          |
| UMD/ESM 模块        | 模块级 | 低\~中 | 中     | 轻量模块复用             |
| Module Federation | 模块级 | 中等   | 中等    | 多项目共建，webpack-only |
| 组件库               | 组件级 | 低    | 低     | UI 组件 / 通用逻辑       |）


# 为什么使用 bpmnjs

项目中的需求是：流程建模 + 表单 + 属性配置的能力，需要满足：
- 用户在前端可视化设计业务流程（审批流）
- 支持 bpmn 规范（支持连线、用户任务、网关）
- 支持拖拽、连接、属性配置
- 支持保存为 xml，导入导出
- 和后端的流程引擎（activiti）对接

基于这些需求选择了 bpmnjs，原因如下：
- 符合 BPMN2.0 标准，易于后端流程引擎集成
- 可扩展性强：提供了事件机制、建模器插件机制
- 社区成熟度高：由 Camunda 维护，社区持续维护，bug 少
- UI 足够简介

（bpmnjs 库衍生出来的库：
- dmn-js：嵌入流程中，用于复杂条件判断的逻辑决策（决策表和决策图）
- diagram-js：流程图框架核心库
- bpmn-moddle：解析和生成 BPMN2.0 XML 的模型工具库
- bpmn-js-properties-panel：侧边栏 “属性面板” 支持
）

选型参考：

- bpmnjs
    - 优势：成熟稳定，扩展性强，支持 BPMN2.0 全规范
    - 缺点：学习曲线陡峭，定制样式比较复杂，对新手开发者不友好
- Draw.io/LogicFlow（滴滴内部开源）
    - 可定制能力强，开源
    - 非专注流程建模，BPMN 支持不完整，整合成本高
- ReactFlow
    - React 技术栈，快速上手，非标准的业务流程建模，适合任务编排
    - 不支持 BPMN规范，需要开发者自己编写语义
- JoinJS
    - 通用图形引擎，灵活，API 丰富
    - 不支持 BPMN，需要自己构建引擎语义
- GoJS
    - 强大，性能优
    - 商业收费，代码封闭，学习成本高


# codemirror + Lezer 选型

需求分析：表达式构建器（规则引擎）

构建一个 表达式输入 + 函数校验 + 语法提示 + 错误高亮的 自定义编辑器

（
- 基本的四则运算支持
- 关系运算支持
- 逻辑函数支持
- 数学表达式的解析与高亮
- 函数自动补全与建议
- 错误提示与校验格式
- 表达式编辑区可视化组件
）

编辑器选型：

- Monaco Editor：vscode 同源编辑器，内置高亮、自动补全、语法提示
- codemirror6：较为轻量，支持高度自定义语法和主题
- Ace Editor：快速接入、轻量编辑，不如 Monaco 灵活，补全方面比较弱

Lezer 是 codemirror6 官方推荐的语法解析器生成器：

- 专门为 **快速、轻量、高性能** 的浏览器语法分析设计
- 可以定义自己的 DSL，自动生成语法树
- 生成的 parser 能很好地和 codemirror 的各种插件（高亮、补全、lint）联动
