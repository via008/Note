# 流程设计器

## 1. 技术选型相关，为什么用这套技术栈？

调研了市面上很多开发流程引擎的工具，大部分都是做商业化的，需要收费。在开源项目的选择中，主要有两种类型:

- 基于 BPMN2.0 规范搭建的 bpmnjs
    - 优点：完善的标准支持、社区成熟、可扩展性强
    - 缺点：上手门槛高、自定义成本高
- 另外一些轻量流程编辑库（比如 React Flow、Drawflow 等）
    - 优点：简洁灵活、集成快、适合 React/Vue 技术栈
    - 缺点：缺少 BPMN 支持，需要二次开发

最终选择：bpmnjs + React + 自定义属性面板 + moddle 扩展

## 2. canvas 画图和 svg 画图有什么区别？

（1）渲染原理不同

**canvas**
- 位图渲染：基于像素，操作的是一个画布上的像素数据
- 绘图是即时渲染，绘制后元素就“固化”在画布中，无法直接访问或操作某个图形对象
- 所有图形变更都需要手动清除画布再重绘

**svg**
- 矢量图形渲染：基于 XML DOM，每一个图形元素都是一个独立的 DOM 节点
- 绘图是声明式的，浏览器根据 DOM 自动渲染
- 每个图形都是可操作的 DOM 元素，可以直接响应事件和样式变化

（2）性能对比

- 少量图形，svg 更方便，维护性更强
- 大量图形，canvas 性能更优，因为操作的是像素，非 ODM
- 频繁动画/更新，canvas 更适合，比如游戏、数据实时刷新

（3）使用场景总结

**svg**
- 图形编辑器、流程图、可视化编辑器
- 矢量图展示、图标、可缩放图形

**canvas**
- 数据量大、频繁刷新（游戏、图表）
- 地图

## 3. 图形之间的连线是如何计算的？

bpmnjs 中采用**曼哈顿布局**的方式计算得出连接线的路径。

曼哈顿布局：一种仅使用水平线和垂直线（即正交路径）的布局策略，用来连接两个图形元素。

核心算法原理：

- 确定连接点
    - 每个节点有 4 个方向可以连线：top、right、bottom、left
    - 首先会计算出源和目标图形四周可以连出的外边中心点
- 枚举所有可选起点/终点方向组合
    - 对每一对组合，尝试生成一条正交路径
- 生成路径：拐点策略
    - 曼哈顿布局默认使用“L 型”、“Z 型”、“┐型”等模式组合线段
    - 每个路径至少有 2 个端点，可能有 1～3 个拐点
    - 所有路径由 {x,y} 坐标组成，称为 waypoints
- 选择最优路径
    - 每条路径都有“成本”：成本=路径长度+拐点惩罚
    - 最终选择“最短+拐点少”的那一条路径

```javascript

function manhattanConnectionPath(source, target, options = {}) {
    const sourceDirections = getDirections(source);
    const targetDirections = getDirections(target);

    const paths = [];

    for(let sDir of sourceDirections) {
        for(let tDir of targetDirections) {
            const start = getAnchor(source, sDir);
            const end = getAnchor(target, tDir);

            const path = computePath(start, sDir, end, tDir); // computePath 计算可能出现的拐点坐标
            const cost = computeCost(path);

            paths.push({ path, cost });
        }
    }

    return pickLowestCost(paths).path;
}

```

## 4. 

# 表单设计器

## 1. 表单 schema 的结构设计

设计原则：
- 节点唯一：唯一 key
- 层级清晰：用树结构描述父子关系
- 可配置：用 props 描述 UI 和行为
- 可嵌套：用 children 支持容器嵌套
- 可扩展：扩展字段


## 2. 拖拽交互复杂度

- 拖拽添加组件、嵌套布局等操作涉及多个状态同步的问题
- 特别是在嵌套容器组件（如分组、tabs、Grid）中拖拽时
    - 如何知道当前目标容器？
    - 如何支持嵌套层级拖拽？
    - 拖拽时的高亮显示、位置判断

dnd-kit 不直接支持树状结构拖拽，但可以使用它的基础能力，结合**树形数据结构+路径定位+受控状态更新**来实现嵌套逻辑。

关键点：
1. 所有组件有唯一 ID，比如路径 ['form', 'container', 'input1']
2. 拖拽时记录“来源路径”和“目标路径”，在结构树中进行剪切+插入
3. 每个容器都作为 droppable，并实现 hover 高亮
4. 拖拽中实时定位放入哪个容器，并更新目标插入点

性能方面：
- 渲染过多：组件 memo
- 状态更新频繁：拖动中不更新 schema、使用局部状态
- 嵌套查找慢：ID Map、immer 更新树结构减少出错
- 拖拽卡顿：避免频繁更新 DOM 结构，尽量用样式控制
- 碰撞检测慢：使用简单的碰撞算法、对于不可见/折叠区域，禁用 droppable 能力


## 3. 如何解析 schema 并渲染出运行态？

- 渲染入口：递归渲染 schema，每个节点渲染组件
- 组件映射：type -> React 组件
- 数据绑定：props + onChange
- 条件/事件：扩展字段解析

## 4. 条件渲染以及渲染性能问题

- 表达式方式
- new Function 转入执行上下文

性能优化：
- 缓存结果
- 缓存渲染节点
- 精准触发渲染（只让相关字段重新渲染）
- 保持渲染树结构稳定，内部尽量 memo+key 保持稳定

## 5. 精准触发渲染 怎么做的？

- 组件初始化：将表达式所依赖的组件放入订阅列表，并传入相关回调函数
- 依赖的值变化：触发对应的回调函数

## 6. 如何封装组件注册机制？

- 注册组件：组件类型，组件 UI
- 左侧面板显示
- 根据 schema 渲染组件

## 7. 新旧JSON转换

实现了一个属性转换器，主要就是 schema 转换。

- 布局转换
- 组件转换
- 数据字典转换
- 联动关系转换
