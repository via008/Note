# 1. 微前端实现原理

- 微前端核心理念：将前端应用像“微服务”一样拆分部署、独立运行、组合呈现
- 主流实现方式：主应用+子应用加载策略
    - 基于 iframe 的方案（早期）
    - 基于 JavaScript 动态加载的“沙箱式微前端”(典型代表：qiankun)
        - 应用注册与生命周期管理：主应用维护子应用注册表，子应用实现生命周期
        - 动态加载子应用资源
        - 运行时沙箱隔离

# 2. CSS 隔离和 js 隔离是怎么做的

- js 隔离：Proxy + new Function
- CSS 隔离
    - Shadow DOM
    - scoped CSS

# 3. 怎么实现通信的

Event Bus + 全局状态共享（redux + shared store）+ props 传参

# 4. 为何要使用 Module Federation？

- Module Federation 是 webpack5 提出的一种机制，允许多个独立构建（bundle）之间**运行时动态加载彼此模块**，并且能共享依赖、复用功能模块或者业务模块，从而实现真正的模块联邦式架构
- 不用安装 npm 包、不发版本、不重新打包的前提下就能完成
- 模块级别的代码复用

# 5. 为什么使用 qiankun？

- qiankun（阿里）
    - 基于 single-spa
    - 优点：HTML entry 方式引用子应用，完备的 js 和 CSS 沙箱方案，静态资源预加载
    - 缺点：适配成本较高，css 沙箱采用严格隔离有各种问题，js 沙箱在某些场景下执行性能下降严重
- single-spa
    - 应用注册
    - 路由匹配&应用加载
    - 生命周期管理
- wujie（腾讯）
    - webcomponent 容器 + iframe js 沙箱
    - 优点：子应用保活，支持子应用嵌套，原生隔离，运行速度快
    - 缺点：
- micro-app（京东）
    - 原理：基于 webcomponent + qiankun sandbox 的微前端方案
    - 优点：支持子应用保活，静态资源预加载
    - 缺点：继承了 qiankun 的缺点并且对浏览器的兼容性有要求（没有做降级处理）
- EMP（Webpack5 Module Federation）
    - 优点：保证子应用依赖解耦；应用间去中心化的调用、共享模块
    - 缺点：老旧项目不友好，没有沙箱机制，路由可能发生冲突

# 6. lerna 管理包怎么做的？

- lerna 用来干什么的？
    - lerna 是一个管理 js/ts 的 monorepo 的工具，主要用于管理多个互相依赖的 npm 包在同一个代码仓库中的开发与发布流程。
- lerna 管理包是怎么做的？
    - 项目结构构建：lerna init + packages/*
    - 本地模块联调：lerna bootstrap，将各模块之间的依赖通过软链接建立起本地关系
    - 修改模块时自动推送版本：lerna publish
    - 单包执行命令

# 7. 为啥要用 service worker？

Service worker 是浏览器提供的一种在后台运行的 js 线程，本质上一个拦截器，用于控制页面和服务器之间的请求响应过程。

- 提升页面的加载速度
- 想让用户离线的情况下也可以访问我们的应用
- 做到可以主动 push 消息

# 8. 它的缓存策略有哪些？

- Cache First（缓存优先）
    - 优先返回缓存，没有缓存再请求网络
    - 样式表、图标、字体等
- Network First（网络优先）
    - 优先请求网络，失败再用缓存（兜底）
    - 数据接口
- Stale While Revalidate（SWR，先缓存同时请求）
    - 先用缓存，同时请求接口更新缓存
    - 用户常访问的页面
- Cache only（仅缓存）
    - 只读缓存
    - 离线模式
- Network Only（仅网络）
    - 只请求接口
    - 登录接口、支付接口

# 9. 为啥后面不用 service worker了？

我们当时的版本迭代相对来说比较快，上线之后老有用户反馈页面加载的是老版本，其实就是我们的策略配置有问题，我们把 index.html 也缓存了

# 10. cli 脚手架工具主要做了哪些事情？

- cli 本质上是一个 “开发流程自动化 + 项目初始化标准”的工具，目标是提升研发效率、统一团队规范、降低新手上手成本。

我这个 cli 工具主要做的事情：
- 初始化项目模板，根据用户选择，拉取不同模板
- 提供开发和构建命令（本地开发体验统一化）
- 封装工程体系，沉淀团队能力

设计原则：有默认值但可扩展 + 文档明确 + 模板规范化

# 11. 性能优化做了哪些事情？你做的这些事情哪个效果最好？

- 加载性能（首次渲染）
    - 指标：FCP
    - 代码分包
    - 路由懒加载
    - 骨架屏
    - 使用 CDN
- 运行性能（使用中）
    - 虚拟列表
    - useMemo / useCallback
    - 事件频率节流
- 开发流程优化（开发中）
    - 配置缓存，实现秒启动

# 12. web-socket 怎么建立连接的？

- websocket 是一种持久化的全双工通信协议，它基于 HTTP 协议握手建立连接，但连接建立后就不再走 HTTP，而是走 TCP 的独立协议，优势：
    - 双向通信、实时性强
    - 减少 HTTP 的连接/握手开销
    - 低延迟
- 连接过程
    - 前端发起连接请求：发送 HTTP 请求头，在 header 中加入 upgrade: websocket 字段表示升级协议
    - 服务端响应 101，确认协议切换
    - 进入长连接状态，双方可以随时发送消息
- 保证连接稳定的问题：
    - 心跳保活
    - 自动重连机制
    - 弱网兼容 & 断线提示


# 13. 前端安全这一块了解哪些？

- XSS
— CSRF

# 14. 对自己后续的职业有什么规划？

- 提升技术能力，尤其是在技术底层的理解，我过往的经历主要是聚焦在落地和应用，对项目整体、技术架构方面缺乏经验
- 做用户规模更大更难的项目
- 过去的经历比较偏执行，希望未来可以主导一个项目

# 15. ES6 之后出了哪些新特性？

核心方向：
- 异步编程（async/await, Promise 增强）
- 语法糖（可选链、空值合并、数字分隔符）
- 类型安全（BigInt、私有字段）
- 性能优化（不可变数组方法、静态初始化块）